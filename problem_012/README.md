# Problem 12: Highly Divisible Triangular Number

**Problem source:** [Project Euler Problem 12](https://projecteuler.net/problem=12)

**Problem statement:**

The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be $1 + 2 + 3 + 4 + 5 + 6 + 7 = 28$. The first ten terms would be:

$$1, 3, 6, 10, 15, 21, 28, 36, 45, 55, \dots$$

Let us list the factors of the first seven triangle numbers:

```
 1: 1
 3: 1, 3
 6: 1, 2, 3, 6
10: 1, 2, 5, 10
15: 1, 3, 5, 15
21: 1, 3, 7, 21
28: 1, 2, 4, 7, 14, 28
```

We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?

---

## Solution 1: Direct Triangular Number Factorization

### Approach

- Generate triangular numbers incrementally using the relation $T_n = T_{n-1} + n$.
- For each triangular number, compute $\tau(T_n)$ by factoring it directly (see **Mathematical Foundation** for the divisor function formula).
- Use **wheel factorization (6k±1)** to efficiently find prime factors.
- Continue until finding the first triangular number with over 500 divisors.

**Reference:** The full Python implementation is available in [`solution_1.py`](solution_1.py).

### Detailed Explanation

- **Step 1: Efficient Prime Factorization**
  - The `number_of_divisors` function implements wheel factorization.
  - First, extract all factors of 2: `while not n%2:` divides out powers of 2.
  - Store `count+1` in the list (since the exponent contributes $(a+1)$ to $\tau$).
  - Next, extract all factors of 3: `while not n%3:` divides out powers of 3.
  - For all other primes, use the **6k±1 pattern**.

- **Step 2: The 6k±1 Wheel Pattern**
  - After removing factors of 2 and 3, all remaining primes must be of the form $6k+1$ or $6k-1$.
  - **Mathematical justification:** Any integer is one of $6k$, $6k+1$, $6k+2$, $6k+3$, $6k+4$, or $6k+5$.
    - $6k$, $6k+2$, $6k+4$ are divisible by 2.
    - $6k+3$ is divisible by 3.
    - Only $6k+1$ and $6k+5$ (i.e., $6k-1$) can be prime (for $k \geq 1$).
  - Start with `f = 5` and `step = 2`.
  - The alternating step: `step = 6-step` toggles between 2 and 4.
    - When `step = 2`, add 2 to go from $6k-1$ to $6k+1$.
    - When `step = 4`, add 4 to go from $6k+1$ to $6(k+1)-1$.
  - This generates the sequence: $5, 7, 11, 13, 17, 19, 23, 25, 29, 31, \ldots$
  - The pattern skips all multiples of 2 and 3, checking only $\frac{1}{3}$ of integers.

- **Step 3: Loop Termination**
  - Continue checking factors while `f*f <= n`.
  - **Why stop at $\sqrt{n}$:** If $n$ has a factor $f > \sqrt{n}$, it must have a corresponding factor $d < \sqrt{n}$ (since $n = f \times d$). All composite numbers are marked by their smaller factors.
  - For each factor found, divide it out completely: `while not n%f:`.
  - Append `count+1` to track the contribution to $\tau(n)$.

- **Step 4: Handle Remaining Prime**
  - After the loop, if `n > 1`, then $n$ itself is a prime factor with exponent 1.
  - Append 2 to represent $(1+1)$.
  - Compute the product: `math.prod(exponents_plus1)` gives $\tau(n)$.

- **Step 5: Main Loop**
  - Initialize `triangle_number = 0`, `n = 0`, `divisor_count = 0`.
  - The loop `while divisor_count <= threshold:` continues until finding the answer.
  - Increment `n` and update the triangular number: `triangle_number += n`.
  - This implements $T_n = T_{n-1} + n$, avoiding the multiplication $\frac{n(n+1)}{2}$.
  - Factor the triangular number: `divisor_count = number_of_divisors(triangle_number)`.
  - When `divisor_count > 500`, the loop terminates and prints the result.

- **Efficiency:** This solution is straightforward but factors increasingly large numbers. The triangular number $T_n$ grows quadratically, so factorization becomes progressively slower. For $T_{12375} \approx 7.66 \times 10^7$, this requires testing factors up to $\sqrt{7.66 \times 10^7} \approx 8752$.

---

## Solution 2: Optimized Factorization Using n and n+1

### Approach

- Exploit the structure of triangular numbers: $T_n = \frac{n(n+1)}{2}$.
- Factor $n$ and $n+1$ separately (much smaller numbers than $T_n$).
- Use the coprimality of consecutive integers and the multiplicative property of $\tau$ (see **Mathematical Foundation** for proofs).
- Track the power of 2 in both factorizations to adjust for division by 2.
- Apply the formula: $\tau(T_n) = \tau(n) \cdot \tau(n+1) \cdot \frac{\nu_2(n) + \nu_2(n+1)}{\nu_2(n) + \nu_2(n+1) + 1}$.

**Reference:** The full Python implementation is available in [`solution_2.py`](solution_2.py).

### Detailed Explanation

- **Step 1: Enhanced Factorization Function**
  - The `number_of_divisors` function now returns **two values**: `(tau_n, power_2)`.
  - This dual-purpose design serves two needs simultaneously:
    1. **Compute $\tau(n)$:** Use the standard formula $(a_1+1)(a_2+1) \cdots (a_k+1)$.
    2. **Track $\nu_2(n)$:** Return the exponent of 2 separately for the formula adjustment.
  - When extracting factors of 2: `power_2 = 0` accumulates the count.
  - The line `exponents_plus1.append(power_2+1)` contributes to $\tau(n)$.
  - The line `return math.prod(exponents_plus1), power_2` returns both pieces of information.

- **Step 2: Why This Dual-Purpose Design is Brilliant**
  - **Avoid redundant computation:** A single factorization pass provides all needed data.
  - **No post-processing:** The power of 2 is extracted during factorization, not after.
  - **Efficiency:** Factoring $n$ once is far cheaper than factoring both $n$ and $T_n$.
  - The same loop that computes `power_2` also contributes `(power_2+1)` to the divisor count calculation.

- **Step 3: Main Search Loop**
  - Initialize `n = 0`, `divisor_count = 0`.
  - The loop `while divisor_count <= threshold:` searches for the answer.
  - Increment `n` and factor both `n` and `n+1`:
    - `tau_n, power2_n = number_of_divisors(n)`
    - `tau_n1, power2_n1 = number_of_divisors(n+1)`
  - Compute the total power of 2 in $n(n+1)$: `power_even = power2_n + power2_n1`.
  - Since exactly one of $n$ or $n+1$ is even, this gives $\nu_2(n(n+1))$.

- **Step 4: The Adjustment Formula**
  - The line `divisor_count = tau_n * tau_n1 * power_even / (power_even + 1)` implements:
    $$\tau(T_n) = \tau(n) \cdot \tau(n+1) \cdot \frac{\nu_2(n(n+1))}{\nu_2(n(n+1)) + 1}$$
  - **Why this formula works:**
    - Without division by 2: $\tau(n(n+1)) = \tau(n) \cdot \tau(n+1)$ (by coprimality).
    - The power of 2 in $n(n+1)$ is `power_even`.
    - This contributes `(power_even + 1)` to the divisor count.
    - After dividing by 2, the power of 2 becomes `power_even - 1`.
    - This contributes `(power_even - 1 + 1) = power_even` to the divisor count.
    - The ratio of contributions is: $\frac{\text{power-even}}{\text{power-even} + 1}$.

- **Step 5: Example Walkthrough (n = 8)**
  - $n = 8 = 2^3$: `tau_n = 4` (divisors: 1, 2, 4, 8), `power2_n = 3`
  - $n+1 = 9 = 3^2$: `tau_n1 = 3` (divisors: 1, 3, 9), `power2_n1 = 0`
  - $T_8 = \frac{8 \times 9}{2} = 36 = 2^2 \times 3^2$
  - `power_even = 3 + 0 = 3`
  - Formula: `divisor_count = 4 × 3 × (3/4) = 9`
  - Verification: $\tau(36) = \tau(2^2) \times \tau(3^2) = 3 \times 3 = 9$ ✓

- **Step 6: Computing the Answer**
  - Once the loop finds `divisor_count > 500`, compute: `answer = n*(n+1)//2`.
  - This is the first triangular number with over 500 divisors.

- **Efficiency:** This solution is dramatically faster than Solution 1. Instead of factoring numbers that grow quadratically (up to $\sim 7.66 \times 10^7$), we factor numbers that grow linearly (up to $\sim 12{,}376$). For $n = 12{,}375$, the largest factor we test is $\sqrt{12{,}376} \approx 111$, compared to $\sqrt{76{,}576{,}500} \approx 8{,}752$ in Solution 1. This represents a **reduction of roughly 99%** in the range of factors tested.

---

## Comparison of Solutions

| Aspect | Solution 1 (Direct) | Solution 2 (Optimized) |
|--------|---------------------|------------------------|
| **Approach** | Factor $T_n$ directly | Factor $n$ and $n+1$ separately |
| **Number Size** | Up to $\sim 7.66 \times 10^7$ | Up to $\sim 12{,}376$ |
| **Trial Division Range** | Up to $\sim 8{,}752$ | Up to $\sim 111$ |
| **Formula Used** | Standard $\tau$ calculation | Multiplicative property with adjustment |
| **Mathematical Insight** | Wheel factorization | Coprimality + multiplicativity |
| **Efficiency** | Moderate | Very high |
| **Code Complexity** | Simple and direct | Slightly more complex |
| **Best For** | Understanding basics | Optimal performance |

---

## Output

```
76576500
```

---

## Mathematical Foundation

### Triangular Numbers

The $n$-th triangular number is defined as:
$T_n = 1 + 2 + 3 + \cdots + n = \frac{n(n+1)}{2}$

**Proof:** 
Let $S = 1 + 2 + 3 + \cdots + n$. Writing the sum forwards and backwards:
```
S = 1    +  2    +  3    + ... + n
S = n    + (n-1) + (n-2) + ... + 1
```
Adding these equations term by term:
$2S = (n+1) + (n+1) + (n+1) + \cdots + (n+1) = n(n+1)$
Therefore: $S = \frac{n(n+1)}{2}$ ∎

### Number of Divisors Function

The **divisor function** $\tau(n)$ counts the positive divisors of $n$.

If $n$ has prime factorization:
$n = p_1^{a_1} \cdot p_2^{a_2} \cdot p_3^{a_3} \cdots p_k^{a_k}$

Then:
$\tau(n) = (a_1 + 1)(a_2 + 1)(a_3 + 1) \cdots (a_k + 1)$

**Why this formula works:** Each divisor of $n$ is formed by choosing an exponent between $0$ and $a_i$ for each prime $p_i$. There are $(a_i + 1)$ choices for each prime, giving $(a_1 + 1)(a_2 + 1) \cdots (a_k + 1)$ total divisors.

### Key Property: Multiplicativity

**Theorem:** If $\gcd(m, n) = 1$ (i.e., $m$ and $n$ are coprime), then:
$\tau(mn) = \tau(m) \cdot \tau(n)$

**Proof:**
Since $\gcd(m, n) = 1$, every divisor $d$ of $mn$ can be uniquely written as $d = d_1 \cdot d_2$ where $d_1 | m$ and $d_2 | n$.

*Uniqueness:* Suppose $d = d_1 \cdot d_2 = d_1' \cdot d_2'$ where $d_1, d_1' | m$ and $d_2, d_2' | n$.

Since $\gcd(m, n) = 1$, we have $\gcd(d_1, d_2) = 1$ and $\gcd(d_1', d_2') = 1$.

From $d_1 \cdot d_2 = d_1' \cdot d_2'$, we get $d_1 | d_1' \cdot d_2'$. 

Since $\gcd(d_1, d_2') = 1$, we must have $d_1 | d_1'$.

By symmetry, $d_1' | d_1$, so $d_1 = d_1'$ and consequently $d_2 = d_2'$. ✓

This establishes a bijection between divisors of $mn$ and pairs $(d_1, d_2)$ where $d_1 | m$ and $d_2 | n$.

Therefore: $\tau(mn) = \tau(m) \cdot \tau(n)$ ∎

### Consecutive Integers are Coprime

**Theorem:** For any positive integer $n$, we have $\gcd(n, n+1) = 1$.

**Proof:** 
Suppose $d$ divides both $n$ and $n+1$. Then $d$ divides their difference:
$d | [(n+1) - n] = 1$

The only positive integer dividing 1 is 1 itself, so $d = 1$. ∎

### The Core Formula for Solution 2

Since $T_n = \frac{n(n+1)}{2}$ and $\gcd(n, n+1) = 1$, we can use the multiplicative property with a crucial adjustment for the division by 2:

**Case 1:** If $n$ is even (so $n = 2^a \cdot m$ where $m$ is odd):
$T_n = \frac{n}{2} \cdot (n+1) = 2^{a-1} \cdot m \cdot (n+1)$

Since $\gcd(2^{a-1} \cdot m, n+1) = 1$ (because $n+1$ is odd and coprime to $m$):
$\tau(T_n) = \tau(2^{a-1} \cdot m) \cdot \tau(n+1)$

The power of 2 in $T_n$ is $a-1$ instead of $a$.

**Case 2:** If $n$ is odd (so $n+1 = 2^b \cdot k$ where $k$ is odd):
$T_n = n \cdot \frac{n+1}{2} = n \cdot 2^{b-1} \cdot k$

Since $\gcd(n, 2^{b-1} \cdot k) = 1$:
$\tau(T_n) = \tau(n) \cdot \tau(2^{b-1} \cdot k)$

**General Formula:**
Let $\nu_2(n)$ denote the exponent of 2 in the prime factorization of $n$ (the 2-adic valuation).

Since exactly one of $n$ or $n+1$ is even:
$\tau(T_n) = \tau(n) \cdot \tau(n+1) \cdot \frac{\nu_2(n) + \nu_2(n+1)}{\nu_2(n) + \nu_2(n+1) + 1}$

This formula captures how dividing by 2 reduces the power of 2 in the factorization, which in turn reduces the divisor count contribution from the factor of 2.

---

## Notes

- The first triangular number with over 500 divisors is $76{,}576{,}500 = T_{12375} = \frac{12375 \times 12376}{2}$.
- This triangular number has exactly **576 divisors**.
- The factorization is: $76{,}576{,}500 = 2^2 \times 3 \times 5^3 \times 7 \times 11 \times 13 \times 17$.
- **Solution 2** is dramatically more efficient than Solution 1. Instead of factoring $T_{12375} \approx 7.66 \times 10^7$, it factors $n = 12{,}375$ and $n+1 = 12{,}376$ (roughly 6,200 times smaller). This reduces the trial division range from $\sim 8{,}752$ down to $\sim 111$, representing a **99% reduction** in computational work.
- The dual-purpose factorization in Solution 2 (returning both $\tau(n)$ and $\nu_2(n)$ from a single pass) eliminates redundant computation. The same loop that counts powers of 2 also contributes to the divisor count calculation.
- The 6k±1 wheel factorization reduces the search space by approximately **67%** compared to checking all odd numbers, and **83%** compared to checking all integers. The toggle mechanism `step = 6-step` elegantly generates the sequence without conditionals.
- The formula $\tau(T_n) = \tau(n) \cdot \tau(n+1) \cdot \frac{\nu_2(n) + \nu_2(n+1)}{\nu_2(n) + \nu_2(n+1) + 1}$ works uniformly for both even and odd $n$ because exactly one of $n$ or $n+1$ is always even.
- The coprimality of consecutive integers ($\gcd(n, n+1) = 1$) is fundamental to Solution 2's efficiency, allowing us to factor smaller numbers independently and use the multiplicative property.
- This problem illustrates how **number theory, combinatorics, and algorithmic optimization** combine to solve computational problems efficiently.
- **Historical note:** This is Project Euler Problem #12, one of the classic problems that separates those who understand divisor functions and efficient factorization from those who rely solely on brute force.
